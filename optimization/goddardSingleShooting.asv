function [cost] = goddardSingleShooting(controls, initialState, finalState, Rocket) 

    % Unpack Rocket Properties 
    thrust = Rocket.thrust; 
    effectiveExhaustVelocity = Rocket.effectiveExhaustVelocity; 
    throttleSmoothing = Rocket.throttleSmoothing; 

    % Define TimeSpan 
    finalEpoch = controls(4); 
    epochs = [0 finalEpoch]; 
    
    % Build Adjoint State 
    initialCostates = controls(1:3); 
    adjointState = [initialState; initialCostates]; 
    
    % Set odeOptions 
    odeopts = odeset('RelTol', 1e-10, 'AbsTol', 1e-12, 'Events', @singularArcs); 
    timeHistory = initalEpoch;
    stateHistory = adjointState; 
    done = false; 
    while ~ done 
        
        % Update timeSpan 
        timeSpan = epochs; 
        % Integrate Dynamics
        if S && Sdot > tolerance 
            [time, trajectory] = ode89(@rocketDynamics_bang, timeSpan, adjointState, odeopts, thrust, effectiveExhaustVelocity, throttleSmoothing);
        else 
            [time, trajectory] = ode89(@rocketDynamics_singular, timeSpan, adjointState, odeopts, thrust, effectiveExhaustVelocity);

        
        % Check if final time is reached 
        done = (time(end) == finalEpoch); 
        
        % Set initialEpoch to finalEpoch of last leg 
        epochs = [time(end), finalEpoch]; 
    
        % Append Trajectory Legs
        timeHistory = [timeHistory; time(2:end)]; 
        stateHistory = [stateHistory; trajectory(2:end,1:3)];


    end 

     
    
    
    
    
    
    
    
    cost = trajectory(end,1:3) - finalState; 
    cost = rmmissing(cost); 
    cost(4) = Hamiltonian(end); 

end